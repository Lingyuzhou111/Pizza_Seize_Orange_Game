<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Roguelikeç”Ÿå­˜</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
            touch-action: none;
        }
        canvas {
            border: 1px solid #333;
            max-width: 100%;
            max-height: 100vh;
        }
        #stats {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-size: calc(12px + 1vw);
            z-index: 100;
        }
        #gameOver {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            text-align: center;
            border-radius: 10px;
            font-size: calc(14px + 1vw);
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="stats">
        æ—¶é—´: <span id="time">0</span>ç§’<br>
        å‡»æ€: <span id="kills">0</span><br>
        å­å¼¹æ•°: <span id="bulletCount">1</span>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div id="gameOver">
        æ¸¸æˆç»“æŸ<br>
        å­˜æ´»æ—¶é—´: <span id="finalTime">0</span>ç§’<br>
        å‡»æ€æ•°: <span id="finalKills">0</span><br>
        <button onclick="restartGame()" style="font-size: calc(12px + 1vw); padding: 10px 20px;">é‡æ–°å¼€å§‹</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // æ·»åŠ è®¾å¤‡æ£€æµ‹å‡½æ•°
        function isMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        // ä¿®æ”¹ç”»å¸ƒå¤§å°è°ƒæ•´å‡½æ•°
        function resizeCanvas() {
            if (isMobile()) {
                // æ‰‹æœºç«¯é€‚é…
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                
                // è°ƒæ•´æ¸¸æˆå…ƒç´ å¤§å°
                if (game) {
                    // æ ¹æ®å±å¹•å¤§å°è°ƒæ•´ç©å®¶å¤§å°
                    game.player.size = Math.min(window.innerWidth, window.innerHeight) * 0.05;
                    // è°ƒæ•´ç©å®¶åˆå§‹ä½ç½®
                    game.player.x = canvas.width / 2;
                    game.player.y = canvas.height / 2;
                }
            } else {
                // ç”µè„‘ç«¯ä¿æŒåŸæœ‰æ¯”ä¾‹
                const maxWidth = 800;
                const maxHeight = 600;
                const windowRatio = window.innerWidth / window.innerHeight;
                const gameRatio = maxWidth / maxHeight;

                if (windowRatio < gameRatio) {
                    canvas.width = window.innerWidth * 0.95;
                    canvas.height = (canvas.width / gameRatio);
                } else {
                    canvas.height = window.innerHeight * 0.95;
                    canvas.width = canvas.height * gameRatio;
                }
            }
        }

        // åˆå§‹åŒ–æ—¶è°ƒæ•´ç”»å¸ƒå¤§å°
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        let game = {
            player: {
                x: canvas.width / 2,
                y: canvas.height / 2,
                size: 25,
                speed: 5,
                bulletCount: 1
            },
            bullets: [],
            enemies: [],
            powerups: [],
            time: 0,
            kills: 0,
            difficulty: 1,
            isGameOver: false,
            lastShot: 0,
            shotDelay: 250
        };

        // æ·»åŠ è§¦å±æ§åˆ¶
        let touchPos = {
            x: 0,
            y: 0,
            touching: false
        };

        // æ·»åŠ è§¦å±äº‹ä»¶ç›‘å¬
        canvas.addEventListener('touchstart', handleTouchStart);
        canvas.addEventListener('touchmove', handleTouchMove);
        canvas.addEventListener('touchend', handleTouchEnd);

        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            touchPos.x = touch.clientX - rect.left;
            touchPos.y = touch.clientY - rect.top;
            touchPos.touching = true;
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (!touchPos.touching) return;
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            touchPos.x = touch.clientX - rect.left;
            touchPos.y = touch.clientY - rect.top;
        }

        function handleTouchEnd() {
            touchPos.touching = false;
        }

        // ä¿®æ”¹updatePlayerPositionå‡½æ•°
        function updatePlayerPosition() {
            let dx = 0;
            let dy = 0;

            if (isMobile()) {
                // è§¦å±æ§åˆ¶
                if (touchPos.touching) {
                    // è®¡ç®—ç©å®¶åº”è¯¥ç§»åŠ¨çš„æ–¹å‘
                    dx = touchPos.x - game.player.x;
                    dy = touchPos.y - game.player.y;
                    // æ ‡å‡†åŒ–å‘é‡
                    const length = Math.sqrt(dx * dx + dy * dy);
                    if (length > 0) {
                        dx = dx / length;
                        dy = dy / length;
                    }
                }
            } else {
                // ç”µè„‘ç«¯é”®ç›˜æ§åˆ¶
                if (keys.w) dy -= 1;
                if (keys.s) dy += 1;
                if (keys.a) dx -= 1;
                if (keys.d) dx += 1;
                
                // æ ‡å‡†åŒ–å‘é‡
                if (dx !== 0 || dy !== 0) {
                    const length = Math.sqrt(dx * dx + dy * dy);
                    dx = dx / length;
                    dy = dy / length;
                }
            }

            // æ›´æ–°ç©å®¶ä½ç½®
            if (dx !== 0 || dy !== 0) {
                game.player.x += dx * game.player.speed;
                game.player.y += dy * game.player.speed;
                
                // ç¡®ä¿ç©å®¶ä¸ä¼šç§»å‡ºç”»å¸ƒ
                game.player.x = Math.max(game.player.size, Math.min(canvas.width - game.player.size, game.player.x));
                game.player.y = Math.max(game.player.size, Math.min(canvas.height - game.player.size, game.player.y));
            }
        }

        // åœ¨ update å‡½æ•°ä¸­æ›¿æ¢åŸæœ‰çš„ç©å®¶ç§»åŠ¨ä»£ç 
        function update() {
            if (game.isGameOver) return;

            shootBullet();
            updatePlayerPosition();

            // å…¶ä½™çš„æ›´æ–°é€»è¾‘ä¿æŒä¸å˜
            for (let i = game.bullets.length - 1; i >= 0; i--) {
                const bullet = game.bullets[i];
                bullet.x += Math.cos(bullet.angle) * bullet.speed;
                bullet.y += Math.sin(bullet.angle) * bullet.speed;
                
                if (bullet.x < 0 || bullet.x > canvas.width || 
                    bullet.y < 0 || bullet.y > canvas.height) {
                    game.bullets.splice(i, 1);
                }
            }

            for (let i = game.enemies.length - 1; i >= 0; i--) {
                const enemy = game.enemies[i];
                const dx = game.player.x - enemy.x;
                const dy = game.player.y - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                enemy.x += (dx / dist) * enemy.speed;
                enemy.y += (dy / dist) * enemy.speed;

                const playerDist = Math.sqrt(
                    Math.pow(game.player.x - enemy.x, 2) + 
                    Math.pow(game.player.y - enemy.y, 2)
                );
                
                if (playerDist < game.player.size + enemy.size) {
                    gameOver();
                    return;
                }

                for (let j = game.bullets.length - 1; j >= 0; j--) {
                    const bullet = game.bullets[j];
                    const bulletDist = Math.sqrt(
                        Math.pow(bullet.x - enemy.x, 2) + 
                        Math.pow(bullet.y - enemy.y, 2)
                    );
                    
                    if (bulletDist < enemy.size) {
                        spawnPowerup(enemy.x, enemy.y);
                        game.enemies.splice(i, 1);
                        game.bullets.splice(j, 1);
                        game.kills++;
                        break;
                    }
                }
            }

            for (let i = game.powerups.length - 1; i >= 0; i--) {
                const powerup = game.powerups[i];
                const dist = Math.sqrt(
                    Math.pow(game.player.x - powerup.x, 2) + 
                    Math.pow(game.player.y - powerup.y, 2)
                );
                
                if (dist < game.player.size + powerup.size) {
                    switch(powerup.type) {
                        case 'addBullet':
                            game.player.bulletCount++;
                            break;
                        case 'clearAll':
                            game.enemies = [];
                            break;
                        case 'slowEnemies':
                            game.enemies.forEach(enemy => {
                                enemy.speed = enemy.baseSpeed * 0.5;
                            });
                            break;
                    }
                    game.powerups.splice(i, 1);
                }
            }

            game.time += 1/60;
            game.difficulty = 1 + Math.floor(game.time / 30) * 0.5;

            if (Math.random() < 0.02 + (game.difficulty * 0.01)) {
                spawnEnemy();
            }

            updateUI();
        }

        // å…¶ä½™å‡½æ•°ä¿æŒä¸å˜
        function findNearestEnemy() {
            if (game.enemies.length === 0) return null;
            
            let nearestEnemy = game.enemies[0];
            let minDistance = Number.MAX_VALUE;
            
            game.enemies.forEach(enemy => {
                const dist = Math.sqrt(
                    Math.pow(game.player.x - enemy.x, 2) + 
                    Math.pow(game.player.y - enemy.y, 2)
                );
                if (dist < minDistance) {
                    minDistance = dist;
                    nearestEnemy = enemy;
                }
            });
            
            return nearestEnemy;
        }

        function spawnEnemy() {
            const side = Math.floor(Math.random() * 4);
            let x, y;
            
            switch(side) {
                case 0: // top
                    x = Math.random() * canvas.width;
                    y = -20;
                    break;
                case 1: // right
                    x = canvas.width + 20;
                    y = Math.random() * canvas.height;
                    break;
                case 2: // bottom
                    x = Math.random() * canvas.width;
                    y = canvas.height + 20;
                    break;
                case 3: // left
                    x = -20;
                    y = Math.random() * canvas.height;
                    break;
            }

            game.enemies.push({
                x: x,
                y: y,
                size: 20,
                speed: 1 + Math.random() * game.difficulty * 0.5,
                baseSpeed: 1 + Math.random() * game.difficulty * 0.5
            });
        }

        function spawnPowerup(x, y) {
            const rand = Math.random() * 100;
            let type = null;
            
            if (rand < 1) {  // 1% æ¦‚ç‡æ‰è½æ¸…å±é“å…·
                type = 'clearAll';
            } else if (rand < 3) {  // 2% æ¦‚ç‡æ‰è½å­å¼¹+1é“å…·
                type = 'addBullet';
            } else if (rand < 8) {  // 5% æ¦‚ç‡æ‰è½å‡é€Ÿé“å…·
                type = 'slowEnemies';
            }

            if (type) {
                game.powerups.push({
                    x: x,
                    y: y,
                    type: type,
                    size: 15  // ç¨å¾®å¢åŠ é“å…·å¤§å°ä»¥ä¾¿æ˜¾ç¤ºemoji
                });
            }
        }

        function shootBullet() {
            const now = Date.now();
            if (now - game.lastShot < game.shotDelay) return;
            
            const nearestEnemy = findNearestEnemy();
            if (!nearestEnemy) return;
            
            const dx = nearestEnemy.x - game.player.x;
            const dy = nearestEnemy.y - game.player.y;
            const angle = Math.atan2(dy, dx);

            for (let i = 0; i < game.player.bulletCount; i++) {
                const spread = (i - (game.player.bulletCount - 1) / 2) * 0.1;
                game.bullets.push({
                    x: game.player.x,
                    y: game.player.y,
                    speed: 10,
                    angle: angle + spread
                });
            }
            
            game.lastShot = now;
        }

        // 1. å…ˆï¼Œå°†å›¾ç‰‡åŠ è½½ç§»åˆ°æ¸¸æˆåˆå§‹åŒ–æ—¶
        const playerImg = new Image();
        let playerImgLoaded = false;

        // åœ¨æ¸¸æˆå¼€å§‹å‰åŠ è½½å›¾ç‰‡
        playerImg.onload = function() {
            playerImgLoaded = true;
            console.log('Player image loaded successfully');
        };
        playerImg.onerror = function() {
            console.error('Failed to load player image');
            playerImgLoaded = false;
        };
        playerImg.src = './imgs/juzi.png';

        // 2. ä¿®æ”¹drawå‡½æ•°ä¸­çš„ç©å®¶ç»˜åˆ¶éƒ¨åˆ†
        function draw() {
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ç”»ç©å®¶
            const playerDisplaySize = game.player.size * 1.5;
            if (playerImgLoaded) {
                ctx.drawImage(playerImg, 
                    game.player.x - playerDisplaySize, 
                    game.player.y - playerDisplaySize, 
                    playerDisplaySize * 2, 
                    playerDisplaySize * 2
                );
            } else {
                // å¦‚æœå›¾ç‰‡æœªåŠ è½½ï¼Œæ˜¾ç¤ºä¸€ä¸ªå ä½ç¬¦
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(game.player.x, game.player.y, playerDisplaySize, 0, Math.PI * 2);
                ctx.fill();
            }

            // ç”»å­å¼¹
            ctx.fillStyle = '#ff0';
            game.bullets.forEach(bullet => {
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 3, 0, Math.PI * 2);
                ctx.fill();
            });

            // ç”»æ•Œäºº - ä½¿ç”¨emoji
            const enemySize = isMobile() ? 
                `${Math.min(window.innerWidth, window.innerHeight) * 0.08}px` : 
                `${game.player.size * 2}px`;
            ctx.font = `${enemySize} Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            game.enemies.forEach(enemy => {
                ctx.fillText('ğŸ•', enemy.x, enemy.y);
            });

            // ç”»é“å…· - ä½¿ç”¨emoji
            const powerupSize = isMobile() ? 
                `${Math.min(window.innerWidth, window.innerHeight) * 0.05}px` : 
                `${game.player.size}px`;
            ctx.font = `${powerupSize} Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            game.powerups.forEach(powerup => {
                switch(powerup.type) {
                    case 'addBullet':
                        ctx.fillText('ğŸ', powerup.x, powerup.y);  // å­å¼¹+1é“å…·
                        break;
                    case 'clearAll':
                        ctx.fillText('ğŸ’£', powerup.x, powerup.y);  // æ¸…å±é“å…·
                        break;
                    case 'slowEnemies':
                        ctx.fillText('ğŸ±', powerup.x, powerup.y);  // å‡é€Ÿé“å…·
                        break;
                }
            });
        }

        function updateUI() {
            document.getElementById('time').textContent = Math.floor(game.time);
            document.getElementById('kills').textContent = game.kills;
            document.getElementById('bulletCount').textContent = game.player.bulletCount;
        }

        function gameOver() {
            game.isGameOver = true;
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('finalTime').textContent = Math.floor(game.time);
            document.getElementById('finalKills').textContent = game.kills;
        }

        function restartGame() {
            game = {
                player: {
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    size: 25,
                    speed: 5,
                    bulletCount: 1
                },
                bullets: [],
                enemies: [],
                powerups: [],
                time: 0,
                kills: 0,
                difficulty: 1,
                isGameOver: false,
                lastShot: 0,
                shotDelay: 250
            };
            document.getElementById('gameOver').style.display = 'none';
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // æ·»åŠ å±å¹•æ–¹å‘å˜åŒ–ç›‘å¬
        window.addEventListener('orientationchange', function() {
            setTimeout(resizeCanvas, 100); // å»¶è¿Ÿæ‰§è¡Œä»¥ç¡®ä¿è·å–æ­£ç¡®çš„å±å¹•å°ºå¯¸
        });

        // ä¿®æ”¹æ¸¸æˆåˆå§‹åŒ–éƒ¨åˆ†
        function initGameEnvironment() {
            if (isMobile()) {
                // æ‰‹æœºç«¯ç‰¹å®šè®¾ç½®
                game.shotDelay = 300;
                game.player.speed = Math.min(window.innerWidth, window.innerHeight) * 0.01;
                
                // æ·»åŠ é˜»æ­¢é¡µé¢æ»šåŠ¨
                document.body.style.overflow = 'hidden';
                document.body.style.position = 'fixed';
            }
        }

        // åœ¨æ¸¸æˆåˆå§‹åŒ–éƒ¨åˆ†æ·»åŠ é”®ç›˜æ§åˆ¶
        const keys = {
            w: false,
            s: false,
            a: false,
            d: false
        };

        document.addEventListener('keydown', (e) => {
            if (keys.hasOwnProperty(e.key.toLowerCase())) {
                keys[e.key.toLowerCase()] = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.key.toLowerCase())) {
                keys[e.key.toLowerCase()] = false;
            }
        });

        // ç¡®ä¿åœ¨æ¸¸æˆåˆå§‹åŒ–æ—¶è°ƒç”¨
        initGameEnvironment();

        gameLoop();
    </script>
</body>
</html>
