<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Roguelike生存</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
            touch-action: none;
        }
        canvas {
            border: 1px solid #333;
            max-width: 100%;
            max-height: 100vh;
        }
        #stats {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-size: calc(12px + 1vw);
            z-index: 100;
        }
        #gameOver {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            text-align: center;
            border-radius: 10px;
            font-size: calc(14px + 1vw);
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="stats">
        时间: <span id="time">0</span>秒<br>
        击杀: <span id="kills">0</span><br>
        子弹数: <span id="bulletCount">1</span>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div id="gameOver">
        游戏结束<br>
        存活时间: <span id="finalTime">0</span>秒<br>
        击杀数: <span id="finalKills">0</span><br>
        <button onclick="restartGame()" style="font-size: calc(12px + 1vw); padding: 10px 20px;">重新开始</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // 添加设备检测函数
        function isMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        // 修改画布大小调整函数
        function resizeCanvas() {
            if (isMobile()) {
                // 手机端适配
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                
                // 调整游戏元素大小
                if (game) {
                    // 根据屏幕大小调整玩家大小
                    game.player.size = Math.min(window.innerWidth, window.innerHeight) * 0.05;
                    // 调整玩家初始位置
                    game.player.x = canvas.width / 2;
                    game.player.y = canvas.height / 2;
                }
            } else {
                // 电脑端保持原有比例
                const maxWidth = 800;
                const maxHeight = 600;
                const windowRatio = window.innerWidth / window.innerHeight;
                const gameRatio = maxWidth / maxHeight;

                if (windowRatio < gameRatio) {
                    canvas.width = window.innerWidth * 0.95;
                    canvas.height = (canvas.width / gameRatio);
                } else {
                    canvas.height = window.innerHeight * 0.95;
                    canvas.width = canvas.height * gameRatio;
                }
            }
        }

        // 初始化时调整画布大小
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        let game = {
            player: {
                x: canvas.width / 2,
                y: canvas.height / 2,
                size: 25,
                speed: 5,
                bulletCount: 1
            },
            bullets: [],
            enemies: [],
            powerups: [],
            time: 0,
            kills: 0,
            difficulty: 1,
            isGameOver: false,
            lastShot: 0,
            shotDelay: 250
        };

        // 添加触屏控制
        let touchPos = {
            x: 0,
            y: 0,
            touching: false
        };

        // 添加触屏事件监听
        canvas.addEventListener('touchstart', handleTouchStart);
        canvas.addEventListener('touchmove', handleTouchMove);
        canvas.addEventListener('touchend', handleTouchEnd);

        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            touchPos.x = touch.clientX - rect.left;
            touchPos.y = touch.clientY - rect.top;
            touchPos.touching = true;
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (!touchPos.touching) return;
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            touchPos.x = touch.clientX - rect.left;
            touchPos.y = touch.clientY - rect.top;
        }

        function handleTouchEnd() {
            touchPos.touching = false;
        }

        // 修改updatePlayerPosition函数
        function updatePlayerPosition() {
            let dx = 0;
            let dy = 0;

            if (isMobile()) {
                // 触屏控制
                if (touchPos.touching) {
                    // 计算玩家应该移动的方向
                    dx = touchPos.x - game.player.x;
                    dy = touchPos.y - game.player.y;
                    // 标准化向量
                    const length = Math.sqrt(dx * dx + dy * dy);
                    if (length > 0) {
                        dx = dx / length;
                        dy = dy / length;
                    }
                }
            } else {
                // 电脑端键盘控制
                if (keys.w) dy -= 1;
                if (keys.s) dy += 1;
                if (keys.a) dx -= 1;
                if (keys.d) dx += 1;
                
                // 标准化向量
                if (dx !== 0 || dy !== 0) {
                    const length = Math.sqrt(dx * dx + dy * dy);
                    dx = dx / length;
                    dy = dy / length;
                }
            }

            // 更新玩家位置
            if (dx !== 0 || dy !== 0) {
                game.player.x += dx * game.player.speed;
                game.player.y += dy * game.player.speed;
                
                // 确保玩家不会移出画布
                game.player.x = Math.max(game.player.size, Math.min(canvas.width - game.player.size, game.player.x));
                game.player.y = Math.max(game.player.size, Math.min(canvas.height - game.player.size, game.player.y));
            }
        }

        // 在 update 函数中替换原有的玩家移动代码
        function update() {
            if (game.isGameOver) return;

            shootBullet();
            updatePlayerPosition();

            // 其余的更新逻辑保持不变
            for (let i = game.bullets.length - 1; i >= 0; i--) {
                const bullet = game.bullets[i];
                bullet.x += Math.cos(bullet.angle) * bullet.speed;
                bullet.y += Math.sin(bullet.angle) * bullet.speed;
                
                if (bullet.x < 0 || bullet.x > canvas.width || 
                    bullet.y < 0 || bullet.y > canvas.height) {
                    game.bullets.splice(i, 1);
                }
            }

            for (let i = game.enemies.length - 1; i >= 0; i--) {
                const enemy = game.enemies[i];
                const dx = game.player.x - enemy.x;
                const dy = game.player.y - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                enemy.x += (dx / dist) * enemy.speed;
                enemy.y += (dy / dist) * enemy.speed;

                const playerDist = Math.sqrt(
                    Math.pow(game.player.x - enemy.x, 2) + 
                    Math.pow(game.player.y - enemy.y, 2)
                );
                
                if (playerDist < game.player.size + enemy.size) {
                    gameOver();
                    return;
                }

                for (let j = game.bullets.length - 1; j >= 0; j--) {
                    const bullet = game.bullets[j];
                    const bulletDist = Math.sqrt(
                        Math.pow(bullet.x - enemy.x, 2) + 
                        Math.pow(bullet.y - enemy.y, 2)
                    );
                    
                    if (bulletDist < enemy.size) {
                        spawnPowerup(enemy.x, enemy.y);
                        game.enemies.splice(i, 1);
                        game.bullets.splice(j, 1);
                        game.kills++;
                        break;
                    }
                }
            }

            for (let i = game.powerups.length - 1; i >= 0; i--) {
                const powerup = game.powerups[i];
                const dist = Math.sqrt(
                    Math.pow(game.player.x - powerup.x, 2) + 
                    Math.pow(game.player.y - powerup.y, 2)
                );
                
                if (dist < game.player.size + powerup.size) {
                    switch(powerup.type) {
                        case 'addBullet':
                            game.player.bulletCount++;
                            break;
                        case 'clearAll':
                            game.enemies = [];
                            break;
                        case 'slowEnemies':
                            game.enemies.forEach(enemy => {
                                enemy.speed = enemy.baseSpeed * 0.5;
                            });
                            break;
                    }
                    game.powerups.splice(i, 1);
                }
            }

            game.time += 1/60;
            game.difficulty = 1 + Math.floor(game.time / 30) * 0.5;

            if (Math.random() < 0.02 + (game.difficulty * 0.01)) {
                spawnEnemy();
            }

            updateUI();
        }

        // 其余函数保持不变
        function findNearestEnemy() {
            if (game.enemies.length === 0) return null;
            
            let nearestEnemy = game.enemies[0];
            let minDistance = Number.MAX_VALUE;
            
            game.enemies.forEach(enemy => {
                const dist = Math.sqrt(
                    Math.pow(game.player.x - enemy.x, 2) + 
                    Math.pow(game.player.y - enemy.y, 2)
                );
                if (dist < minDistance) {
                    minDistance = dist;
                    nearestEnemy = enemy;
                }
            });
            
            return nearestEnemy;
        }

        function spawnEnemy() {
            const side = Math.floor(Math.random() * 4);
            let x, y;
            
            switch(side) {
                case 0: // top
                    x = Math.random() * canvas.width;
                    y = -20;
                    break;
                case 1: // right
                    x = canvas.width + 20;
                    y = Math.random() * canvas.height;
                    break;
                case 2: // bottom
                    x = Math.random() * canvas.width;
                    y = canvas.height + 20;
                    break;
                case 3: // left
                    x = -20;
                    y = Math.random() * canvas.height;
                    break;
            }

            game.enemies.push({
                x: x,
                y: y,
                size: 20,
                speed: 1 + Math.random() * game.difficulty * 0.5,
                baseSpeed: 1 + Math.random() * game.difficulty * 0.5
            });
        }

        function spawnPowerup(x, y) {
            const rand = Math.random() * 100;
            let type = null;
            
            if (rand < 1) {  // 1% 概率掉落清屏道具
                type = 'clearAll';
            } else if (rand < 3) {  // 2% 概率掉落子弹+1道具
                type = 'addBullet';
            } else if (rand < 8) {  // 5% 概率掉落减速道具
                type = 'slowEnemies';
            }

            if (type) {
                game.powerups.push({
                    x: x,
                    y: y,
                    type: type,
                    size: 15  // 稍微增加道具大小以便显示emoji
                });
            }
        }

        function shootBullet() {
            const now = Date.now();
            if (now - game.lastShot < game.shotDelay) return;
            
            const nearestEnemy = findNearestEnemy();
            if (!nearestEnemy) return;
            
            const dx = nearestEnemy.x - game.player.x;
            const dy = nearestEnemy.y - game.player.y;
            const angle = Math.atan2(dy, dx);

            for (let i = 0; i < game.player.bulletCount; i++) {
                const spread = (i - (game.player.bulletCount - 1) / 2) * 0.1;
                game.bullets.push({
                    x: game.player.x,
                    y: game.player.y,
                    speed: 10,
                    angle: angle + spread
                });
            }
            
            game.lastShot = now;
        }

        // 1. 先，将图片加载移到游戏初始化时
        const playerImg = new Image();
        let playerImgLoaded = false;

        // 在游戏开始前加载图片
        playerImg.onload = function() {
            playerImgLoaded = true;
            console.log('Player image loaded successfully');
        };
        playerImg.onerror = function() {
            console.error('Failed to load player image');
            playerImgLoaded = false;
        };
        playerImg.src = './imgs/juzi.png';

        // 2. 修改draw函数中的玩家绘制部分
        function draw() {
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 画玩家
            const playerDisplaySize = game.player.size * 1.5;
            if (playerImgLoaded) {
                ctx.drawImage(playerImg, 
                    game.player.x - playerDisplaySize, 
                    game.player.y - playerDisplaySize, 
                    playerDisplaySize * 2, 
                    playerDisplaySize * 2
                );
            } else {
                // 如果图片未加载，显示一个占位符
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(game.player.x, game.player.y, playerDisplaySize, 0, Math.PI * 2);
                ctx.fill();
            }

            // 画子弹
            ctx.fillStyle = '#ff0';
            game.bullets.forEach(bullet => {
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 3, 0, Math.PI * 2);
                ctx.fill();
            });

            // 画敌人 - 使用emoji
            const enemySize = isMobile() ? 
                `${Math.min(window.innerWidth, window.innerHeight) * 0.08}px` : 
                `${game.player.size * 2}px`;
            ctx.font = `${enemySize} Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            game.enemies.forEach(enemy => {
                ctx.fillText('🍕', enemy.x, enemy.y);
            });

            // 画道具 - 使用emoji
            const powerupSize = isMobile() ? 
                `${Math.min(window.innerWidth, window.innerHeight) * 0.05}px` : 
                `${game.player.size}px`;
            ctx.font = `${powerupSize} Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            game.powerups.forEach(powerup => {
                switch(powerup.type) {
                    case 'addBullet':
                        ctx.fillText('🐞', powerup.x, powerup.y);  // 子弹+1道具
                        break;
                    case 'clearAll':
                        ctx.fillText('💣', powerup.x, powerup.y);  // 清屏道具
                        break;
                    case 'slowEnemies':
                        ctx.fillText('🐱', powerup.x, powerup.y);  // 减速道具
                        break;
                }
            });
        }

        function updateUI() {
            document.getElementById('time').textContent = Math.floor(game.time);
            document.getElementById('kills').textContent = game.kills;
            document.getElementById('bulletCount').textContent = game.player.bulletCount;
        }

        function gameOver() {
            game.isGameOver = true;
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('finalTime').textContent = Math.floor(game.time);
            document.getElementById('finalKills').textContent = game.kills;
        }

        function restartGame() {
            game = {
                player: {
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    size: 25,
                    speed: 5,
                    bulletCount: 1
                },
                bullets: [],
                enemies: [],
                powerups: [],
                time: 0,
                kills: 0,
                difficulty: 1,
                isGameOver: false,
                lastShot: 0,
                shotDelay: 250
            };
            document.getElementById('gameOver').style.display = 'none';
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // 添加屏幕方向变化监听
        window.addEventListener('orientationchange', function() {
            setTimeout(resizeCanvas, 100); // 延迟执行以确保获取正确的屏幕尺寸
        });

        // 修改游戏初始化部分
        function initGameEnvironment() {
            if (isMobile()) {
                // 手机端特定设置
                game.shotDelay = 300;
                game.player.speed = Math.min(window.innerWidth, window.innerHeight) * 0.01;
                
                // 添加阻止页面滚动
                document.body.style.overflow = 'hidden';
                document.body.style.position = 'fixed';
            }
        }

        // 在游戏初始化部分添加键盘控制
        const keys = {
            w: false,
            s: false,
            a: false,
            d: false
        };

        document.addEventListener('keydown', (e) => {
            if (keys.hasOwnProperty(e.key.toLowerCase())) {
                keys[e.key.toLowerCase()] = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.key.toLowerCase())) {
                keys[e.key.toLowerCase()] = false;
            }
        });

        // 确保在游戏初始化时调用
        initGameEnvironment();

        gameLoop();
    </script>
</body>
</html>
